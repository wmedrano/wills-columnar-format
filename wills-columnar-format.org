#+title: Will's Columnar Format
#+author: Will Medrano
#+email: will.s.medrano@gmail.com
#+date: 2023-04-23

* Introduction

*Will's Columnar Format V0*

[[https://wmedrano.dev/literate-programs/wills-columnar-format][Will's Columnar Format]] is a columnar format made by will.s.medrano@gmail.com. It
is primarily implemented for educational purposes. If you are interested in
using a well supported columnar format, consider using [[https://parquet.apache.org/][Apache Parquet]].

** Conventions

The following conventions are used:
- All structs are encoded using [[https://github.com/bincode-org/bincode][Bincode]]. Bincode is a binary
  encoding/decoding scheme implemented in Rust.
- Source code snippets are presented for relatively high level constructs. Lower
  level details may be omitted from presentation.

** Building and Testing Library

Will's Columnar Format is programmed in Org mode with Rust code
blocks. Compiling requires Emacs and Cargo, the Rust package manager. To
generate the Rust source code:

1. Open =wills-columnar-format.org= file in Emacs.
1. Generate the Rust source code by running: ~M-x org-babel-tangle~.
1. Exit Emacs.
1. Compile with the library with ~cargo build~.
1. Run tests with ~cargo test~.

* API

** Features

*** V0 Features

V0 is roughly implemented but still requires graceful error handling, and
bench-marking.

Supports:
- Only a single column per encode/decode.
- Integer (both signed and unsigned) and String types.
- Run length encoding.

*** Tentative V1 Features

- Dictionary encoding for better string compression.
- Compression (like zstd or snappy) for data.
- Multiple columns.
- Push down filtering.
- Split column data into blocks. Required to implement effective push down filtering.


** Encoding

~encode_column~ encodes a ~Vec<T>~ into Will's Columnar Format. If ~use_rle~ is
true, then run length encoding will be used.

TODO: ~use_rle~ should have more granular values like =NEVER=, =ALWAYS=, and
=AUTO=.

#+BEGIN_SRC rust :tangle src/lib.rs :comments both
  pub fn encode_column<T>(data: Vec<T>, use_rle: bool) -> Vec<u8>
  where
      T: 'static + bincode::Encode + Eq {
      encode_column_impl(data, use_rle)
  }
#+END_SRC

** Decoding

~decode_column~ decodes data from a byte stream into a ~Vec<T>~.

TODO: Decoding should return an iterator of ~rle::Element<T>~ to support efficient
reads of run-length-encoded data.

#+BEGIN_SRC rust :tangle src/lib.rs :comments both
  pub fn decode_column<T>(r: &mut impl std::io::Read) -> Vec<T>
  where
      T: 'static + Clone + bincode::Decode {
      decode_column_impl(r)
  }
#+END_SRC

** Tests

#+BEGIN_SRC rust :tangle src/lib.rs :comments both :exports none
  #[cfg(test)]
  mod test_lib;
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments both :exports none
  use super::*;
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments both
  #[test]
  fn test_header_contains_magic_bytes() {
      let data: Vec<i64> = vec![1, 2, 3, 4];
      let encoded_data = encode_column(data.clone(), false);
      assert_eq!(&encoded_data[0..MAGIC_BYTES_LEN], b"wmedrano0");
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments both :exports none
  fn test_encode_decode_for_type<T>()
  where
      T: 'static + Clone + Default + Encode + Decode + Eq + std::fmt::Debug{
      let data: Vec<T> = vec![T::default()];
      let encoded_data = encode_column(data.clone(), false);
      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_eq!(
          decode_column::<T>(&mut encoded_data_cursor),
          vec![T::default()]);
  }
  #[test]
  fn test_encode_decode_several() {
      test_encode_decode_for_type::<i8>();
      test_encode_decode_for_type::<u8>();
      test_encode_decode_for_type::<i16>();
      test_encode_decode_for_type::<u16>();
      test_encode_decode_for_type::<i32>();
      test_encode_decode_for_type::<u32>();
      test_encode_decode_for_type::<i64>();
      test_encode_decode_for_type::<u64>();
      test_encode_decode_for_type::<String>();
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments both
  #[test]
  fn test_encode_decode_integer() {
      let data: Vec<i64> = vec![-1, 10, 10, 10, 11, 12, 12, 10];
      let encoded_data = encode_column(data.clone(), false);
      assert_eq!(encoded_data.len(), 22);

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_eq!(
          decode_column::<i64>(&mut encoded_data_cursor),
          vec![-1, 10, 10, 10, 11, 12, 12, 10]);
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments both
  #[test]
  fn test_encode_decode_string() {
      let data: Vec<&'static str> = Vec::from_iter([
          "foo",
          "foo",
          "foo",
          "bar",
          "baz",
          "foo",
      ].into_iter());
      let encoded_data = encode_column(data.clone(), false);
      assert_eq!(encoded_data.len(), 38);

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_eq!(
          decode_column::<String>(&mut encoded_data_cursor),
          vec!["foo", "foo", "foo", "bar", "baz", "foo"]);
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments both
  #[test]
  fn test_encode_decode_string_with_rle() {
      let data = [
          "foo",
          "foo",
          "foo",
          "bar",
          "baz",
          "foo",
      ];
      let encoded_data = encode_column(data.to_vec(), true);
      assert_eq!(encoded_data.len(), 34);

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_eq!(
          decode_column::<String>(&mut encoded_data_cursor),
          vec!["foo", "foo", "foo", "bar", "baz", "foo"]);
  }
#+END_SRC

* Optimization Tips

** Sorting Data

Sorting may be very beneficial if:

- Order is not important.
- There are lots of repeated values.

If the above are true, try sorting and enabling run length encoding. Run length
encoding is efficient at storing data that is heavily repeated. By sorting, the
data will have longer runs of consecutive repeated values.

* Format Specification

** Format Overview

- =magic-bytes= - The magic bytes are 9 bytes long with the contents being "wmedrano0".
- =header= - The header contains metadata about the column.
- =data= - The encoded column data.

#+BEGIN_SRC rust :tangle src/lib.rs :comments both :exports none
  const MAGIC_BYTES_LEN: usize = 9;
  const MAGIC_BYTES: &[u8; MAGIC_BYTES_LEN] = b"wmedrano0";
  const BINCODE_DATA_CONFIG: bincode::config::Configuration = bincode::config::standard();

  fn encode_column_impl<T: 'static + bincode::Encode + Eq>(data: Vec<T>, use_rle: bool) -> Vec<u8> {
      let elements = data.len();
      let encoded_data = if use_rle {
          let rle_data = rle::encode_data(data.into_iter()).collect::<Vec<_>>();
          bincode::encode_to_vec(rle_data, BINCODE_DATA_CONFIG).unwrap()
      } else {
          bincode::encode_to_vec(data, BINCODE_DATA_CONFIG).unwrap()
      };
      let header = Header{
          data_type: DataType::from_type::<T>().unwrap(),
          is_rle: use_rle,
          elements,
          data_size: encoded_data.len(),
      };
      Vec::from_iter(
          MAGIC_BYTES.iter().copied()
              .chain(header.encode())
              .chain(encoded_data.iter().copied()),
      )
  }

  fn decode_column_impl<T: 'static + Clone + bincode::Decode>(r: &mut impl std::io::Read) -> Vec<T> {
      let mut magic_string = [0u8; MAGIC_BYTES_LEN];
      r.read_exact(&mut magic_string).unwrap();
      assert_eq!(
          &magic_string, MAGIC_BYTES,
          "Expected magic string {:?}.",
          MAGIC_BYTES
      );
      let header = Header::decode(r);
      assert!(
          header.data_type.is_supported::<T>(),
          "Format of expected type {:?} does not support {:?}.",
          header.data_type,
          std::any::type_name::<T>(),
      );
      if header.is_rle {
          let rle_elements: Vec<rle::Element<T>> =
              bincode::decode_from_std_read(r, BINCODE_DATA_CONFIG).unwrap();
          vec_from_iter_with_hint(
              rle::decode_data(rle_elements.iter()).cloned(),
              header.elements,
          )
      } else {
          bincode::decode_from_std_read(r, BINCODE_DATA_CONFIG).unwrap()
      }
  }

  fn vec_from_iter_with_hint<T>(iter: impl Iterator<Item = T>, len_hint: usize) -> Vec<T> {
      let mut ret = Vec::with_capacity(len_hint);
      ret.extend(iter);
      ret
  }
#+END_SRC

** Header

The header contains a Bincode V2 encoded struct:

#+BEGIN_SRC rust :exports none :tangle src/lib.rs :comments both
  use bincode::{Decode, Encode};
  use std::any::TypeId;

  impl Header {
      const CONFIGURATION: bincode::config::Configuration = bincode::config::standard();
  }

  impl DataType {
      const ALL_DATA_TYPE: [DataType; 2] = [
          DataType::Integer,
          DataType::String,
      ];

      fn from_type<T: 'static>() -> Option<DataType> {
          DataType::ALL_DATA_TYPE.into_iter().find(|dt| dt.is_supported::<T>())
      }

      fn is_supported<T: 'static>(&self) -> bool {
          let type_id = TypeId::of::<T>();
          match self {
              DataType::Integer => [
                  TypeId::of::<i8>(),
                  TypeId::of::<u8>(),
                  TypeId::of::<i16>(),
                  TypeId::of::<u16>(),
                  TypeId::of::<i32>(),
                  TypeId::of::<u32>(),
                  TypeId::of::<u64>(),
                  TypeId::of::<i64>(),
              ].contains(&type_id),
              DataType::String => [
                  TypeId::of::<String>(),
                  TypeId::of::<&'static str>(),
              ].contains(&type_id),
          }
      }
  }

  impl Header {
      fn encode(&self) -> Vec<u8> {
          bincode::encode_to_vec(self, Self::CONFIGURATION).unwrap()
      }

      fn decode(r: &mut impl std::io::Read) -> Header {
          bincode::decode_from_std_read(r, Self::CONFIGURATION).unwrap()
      }
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/lib.rs :comments both
  #[derive(Encode, Decode, PartialEq, Eq, Copy, Clone, Debug)]
  pub struct Header {
      pub data_type: DataType,
      pub is_rle: bool,
      pub elements: usize,
      pub data_size: usize,
  }

  #[derive(Encode, Decode, PartialEq, Eq, Copy, Clone, Debug)]
  pub enum DataType {
      Integer = 0,
      String = 1,
  }
#+END_SRC

* Data Encoding

** Basic Encoding

The data consists of a sequence of encoded data. Encoding happens using the Rust
[[https:github.com/bincode-org/bincode][Bincode]] v2 package to encode/decode data of type ~&[T]~ and ~Vec<T>~.

Note: Bincode v2 currently in release candidate mode.

** Run Length Encoding

[[https://en.wikipedia.org/wiki/Run-length_encoding#:~:text=Run%2Dlength%20encoding%20(RLE),than%20as%20the%20original%20run.][Run length encoding]] is a compression technique for repeated values.

For RLE, the data is encoded as a Struct with the run length and the
element. With Bincode, this is the equivalent (storage wise) of encoding a tuple
of type ~(run_length, element)~.

#+BEGIN_SRC rust :tangle src/lib.rs :exports none :comments both
  pub mod rle;
#+END_SRC

#+BEGIN_SRC rust :tangle src/rle.rs :exports none :comments both
  use bincode::{Decode, Encode};
#+END_SRC

#+BEGIN_SRC rust :tangle src/rle.rs :comments both
  #[derive(Encode, Decode, Copy, Clone, PartialEq, Debug)]
  pub struct Element<T> {
      // Run length is stored as a u64. We could try using a smaller datatype,
      // but Bincode uses "variable length encoding" for integers which is
      // efficient for smaller sizes.
      pub run_length: u64,
      pub element: T,
  }

  pub fn encode_data<T: Eq>(data: impl Iterator<Item = T>) -> impl Iterator<Item=Element<T>> {
      EncodeIter{inner: data.peekable()}
  }

  pub fn decode_data<'a, T: 'static>(
      iter: impl 'a + Iterator<Item = &'a Element<T>>,
  ) -> impl Iterator<Item = &'a T> {
      iter.flat_map(move |rle| {
          let run_length = rle.run_length as usize;
          std::iter::repeat(&rle.element).take(run_length)
      })
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/rle.rs :exports none :comments both
  struct EncodeIter<I: Iterator> {
      inner: std::iter::Peekable<I>,
  }

  impl<I> Iterator for EncodeIter<I>
  where I: Iterator,
        I::Item: PartialEq {
      type Item = Element<I::Item>;

      fn next(&mut self) -> Option<Element<I::Item>> {
          let element = match self.inner.next() {
              Some(e) => e,
              None => return None,
          };
          let mut run_length = 1;
          while self.inner.next_if_eq(&element).is_some() {
              run_length += 1;
          }
          Some(Element{element, run_length})
      }
  }
#+END_SRC

*** Tests

#+BEGIN_SRC rust :tangle src/lib.rs :comments both :exports none
  #[cfg(test)]
  mod test_rle;
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_rle.rs :comments both :exports none
  use crate::rle::*;
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_rle.rs :comments both
  #[test]
  fn test_encode_data_compacts_repeated_elements() {
      let data = [
          "repeated-3", "repeated-3", "repeated-3",
          "no-repeat",
          "repeated-2", "repeated-2",
          "repeated-3", "repeated-3", "repeated-3",
      ];
      assert_eq!(
          encode_data(data.into_iter()).collect::<Vec<_>>(),
          vec![
              Element{run_length: 3, element: "repeated-3"},
              Element{run_length: 1, element: "no-repeat"},
              Element{run_length: 2, element: "repeated-2"},
              Element{run_length: 3, element: "repeated-3"},
          ],
      );
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_rle.rs :comments both
  #[test]
  fn test_decode_repeats_elements_by_run_length() {
      let data = vec![
          Element{run_length: 3, element: "repeated-3"},
          Element{run_length: 1, element: "no-repeat"},
          Element{run_length: 2, element: "repeated-2"},
          Element{run_length: 3, element: "repeated-3"},
    ];
    let decoded_data: Vec<&str> = decode_data(data.iter()).cloned().collect();
    assert_eq!(
        decoded_data,
        [
            "repeated-3", "repeated-3", "repeated-3",
            "no-repeat",
            "repeated-2", "repeated-2",
            "repeated-3", "repeated-3", "repeated-3",
        ]
    );
  }
#+END_SRC

* Source Code

The source code is stored at
[[https://github.com/wmedrano/wills-columnar-format]]. The main source file is
=wills-columnar-format.org= which is used to generate the Rust source files like
=src/lib.rs=.
