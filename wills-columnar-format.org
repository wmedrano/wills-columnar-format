:PROPERTIES:
:header-args: :comments link
:END:
#+title: Will's Columnar Format
#+author: Will Medrano
#+email: will.s.medrano@gmail.com
#+date: 2023-04-23

* Introduction
:PROPERTIES:
:CUSTOM_ID: Introduction-h6a696o03tj0
:END:

*Will's Columnar Format V0*

[[https://wmedrano.dev/literate-programs/wills-columnar-format][Will's Columnar Format]] is a columnar format made by will.s.medrano@gmail.com. It
is primarily implemented for educational purposes. If you are interested in
using a well supported columnar format, consider using [[https://parquet.apache.org/][Apache Parquet]].

** Conventions
:PROPERTIES:
:CUSTOM_ID: IntroductionConventions-gbb696o03tj0
:END:

The following conventions are used:
- All structs are encoded using [[https://github.com/bincode-org/bincode][Bincode]]. Bincode is a binary
  encoding/decoding scheme implemented in Rust.
- Source code snippets are presented for relatively high level constructs. Lower
  level details may be omitted from presentation.

** Building and Testing Library
:PROPERTIES:
:CUSTOM_ID: IntroductionBuildingandTestingLibrary-r0c696o03tj0
:END:

Will's Columnar Format is programmed in Org mode with Rust code
blocks. Compiling requires:

1. Emacs - Text editor and lisp environment.
2. Cargo - The Rust package manager.

To generate the Rust source code, run ~M-x org-babel-tangle~ for
=wills-columnar-format.org= within Emacs. To automatically tangle the current
file on save, run:

#+begin_src emacs-lisp
  (add-hook 'after-save-hook #'org-babel-tangle 0 t)
#+end_src

Building and testing relies on Cargo.

#+begin_src shell
  cargo build
  cargo test
  cargo test $FN_TO_TEST
#+end_src

** Dependencies
:PROPERTIES:
:CUSTOM_ID: IntroductionCargotoml-cqc696o03tj0
:END:

Rust dependencies are automatically fetched with Cargo. This library depends on
the following crates:

#+begin_src toml :tangle Cargo.toml :exports none
  [package]
  name = "columnar-format"
  version = "0.1.0"
  edition = "2021"
  # See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
  [dependencies]
#+end_src

#+begin_src toml :tangle Cargo.toml
  # Note: Bincode v2 currently in release candidate. This should be bumped to 2.0
  # once Bincode v2 is released.
  bincode = "2.0.0-rc.3"
  itertools = "0.10"
#+end_src

#+begin_src rust :tangle src/lib.rs :exports none
  pub mod rle;

  #[cfg(test)]
  mod test_bincode;
  #[cfg(test)]
  mod test_lib;
  #[cfg(test)]
  mod test_rle;

  use bincode::{Decode, Encode};
  use itertools::Either;
  use std::{any::TypeId, io::Read, marker::PhantomData};
#+end_src

#+begin_src rust :tangle src/rle.rs :exports none
  use bincode::{Decode, Encode};
  use itertools::Itertools;
#+end_src

#+begin_src rust :tangle src/test_bincode.rs :exports none
  use crate::rle;
#+end_src

#+begin_src rust :tangle src/test_lib.rs :exports none
  use super::*;
  use itertools::assert_equal;
#+end_src

#+begin_src rust :tangle src/test_rle.rs :exports none
  use crate::rle::*;
  use itertools::assert_equal;
#+end_src


* Features
:PROPERTIES:
:CUSTOM_ID: Features-0ed696o03tj0
:END:

*** V0 Features
:PROPERTIES:
:CUSTOM_ID: FeaturesV0Features-81e696o03tj0
:END:

V0 is roughly implemented but still requires graceful error handling, and
bench-marking.

Supports:
- Only a single column per encode/decode.
- Integer (both signed and unsigned) and String types.
- Run length encoding.

*** Tentative V1 Features
:PROPERTIES:
:CUSTOM_ID: FeaturesTentativeV1Features-ppe696o03tj0
:END:

- Automatically determine if RLE should be applied.
- Dictionary encoding for better string compression.
- Compression (like zstd or snappy) for data.
- Multiple columns.
- Push down filtering.
- Split column data into blocks. Required to implement effective push down filtering.

* API
:PROPERTIES:
:CUSTOM_ID: API-6ef696o03tj0
:END:

** Encoding
:PROPERTIES:
:CUSTOM_ID: APIEncoding-w0g696o03tj0
:END:

~encode_column~ encodes a ~Vec<T>~ into Will's Columnar Format. If ~use_rle~ is
true, then run length encoding will be used.

#+begin_src rust :tangle src/lib.rs
  pub fn encode_column<Iter, T>(data: Iter, use_rle: bool) -> Vec<u8>
  where
      Iter: ExactSizeIterator + Iterator<Item = T>,
      T: 'static + bincode::Encode + Eq,
  {
      encode_column_impl(data, use_rle)
  }
#+end_src

** Decoding
:PROPERTIES:
:CUSTOM_ID: APIDecoding-npg696o03tj0
:END:

~decode_column~ decodes data from a byte stream into an iterator of
~rle::Element<T>~. See [[id:DataEncodingRunLengthEncoding-0vm696o03tj0][Run Length Encoding]].

#+begin_src rust :tangle src/lib.rs
  pub fn decode_column<T>(r: &'_ mut impl std::io::Read) -> impl '_ + Iterator<Item = rle::Element<T>>
  where
      T: 'static + bincode::Decode,
  {
      decode_column_impl(r)
  }
#+end_src

** Optimization Tips
:PROPERTIES:
:CUSTOM_ID: OptimizationTips-45i696o03tj0
:END:

*** Sorting Data
:PROPERTIES:
:CUSTOM_ID: OptimizationTipsSortingData-rsi696o03tj0
:END:

If:
- Order does not matter.
- There are lots of repeated values.

If the above are true, try sorting and enabling run length encoding. Run length
encoding is efficient at storing data that is heavily repeated. By sorting, the
data will have longer runs of consecutive repeated values. See [[id:DataEncodingRunLengthEncoding-0vm696o03tj0][Run Length
Encoding]] for technical details.

** Tests
:PROPERTIES:
:CUSTOM_ID: APITests-vfh696o03tj0
:END:

#+begin_src rust :tangle src/test_lib.rs
  #[test]
  fn test_encoding_prefixed_by_magic_bytes() {
      let data: Vec<i64> = vec![1, 2, 3, 4];
      let encoded_data: Vec<u8> = encode_column(data.into_iter(), false);
      assert_eq!(&encoded_data[0..MAGIC_BYTES_LEN], b"wmedrano0");
  }
#+end_src

#+begin_src rust :tangle src/test_lib.rs :exports none
  fn test_can_encode_and_decode_for_type<T>(elements: [T; 2])
  where
      T: 'static + Clone + Encode + Decode + Eq + std::fmt::Debug,
  {
      let data: Vec<T> = elements.to_vec();
      let encoded_data: Vec<u8> = encode_column(data.into_iter(), false);
      assert_eq!(&encoded_data[0..9], b"wmedrano0");
      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_equal(
          decode_column::<T>(&mut encoded_data_cursor),
          [
              rle::Element {
                  element: elements[0].clone(),
                  run_length: 1,
              },
              rle::Element {
                  element: elements[1].clone(),
                  run_length: 1,
              },
          ],
      );
  }
#+end_src

#+begin_src rust :tangle src/test_lib.rs
  #[test]
  fn test_encode_decode_several() {
      test_can_encode_and_decode_for_type::<i8>([-1, -1]);
      test_can_encode_and_decode_for_type::<u8>([1, 2]);
      test_can_encode_and_decode_for_type::<i16>([-1, 1]);
      test_can_encode_and_decode_for_type::<u16>([1, 2]);
      test_can_encode_and_decode_for_type::<i32>([-1, 1]);
      test_can_encode_and_decode_for_type::<u32>([1, 2]);
      test_can_encode_and_decode_for_type::<i64>([-1, 1]);
      test_can_encode_and_decode_for_type::<u64>([1, 2]);
      test_can_encode_and_decode_for_type::<String>(["a".to_string(), "b".to_string()]);
  }
#+end_src

#+begin_src rust :tangle src/test_lib.rs
  #[test]
  fn test_encode_decode_integer() {
      let data: Vec<i64> = vec![-1, 10, 10, 10, 11, 12, 12, 10];
      let encoded_data = encode_column(data.into_iter(), false);
      assert_eq!(
          encoded_data.len(),
          [
              9, // magic_bytes
              1, // u8 header:data_type
              1, // u8 header:use_rle
              1, // varint header:element_count
              1, // varint header:data_size
              8, // data contains 8 elements of varint with size 1.
          ]
          .iter()
          .sum()
      );

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_equal(
          decode_column::<i64>(&mut encoded_data_cursor),
          [
              rle::Element {
                  element: -1,
                  run_length: 1,
              },
              rle::Element {
                  element: 10,
                  run_length: 1,
              },
              rle::Element {
                  element: 10,
                  run_length: 1,
              },
              rle::Element {
                  element: 10,
                  run_length: 1,
              },
              rle::Element {
                  element: 11,
                  run_length: 1,
              },
              rle::Element {
                  element: 12,
                  run_length: 1,
              },
              rle::Element {
                  element: 12,
                  run_length: 1,
              },
              rle::Element {
                  element: 10,
                  run_length: 1,
              },
          ],
      );
  }
#+end_src

#+begin_src rust :tangle src/test_lib.rs
  #[test]
  fn test_encode_decode_string() {
      let data: Vec<&'static str> = vec!["foo", "foo", "foo", "bar", "baz", "foo"];
      let encoded_data = encode_column(data.into_iter(), false);
      assert_eq!(
          encoded_data.len(),
          [
              9,  // magic_bytes
              1,  // u8 header:data_type
              1,  // u8 header:use_rle
              1,  // varint header:element_count
              1,  // varint header:data_size
              24, // data contains 8 elements of varint with size 1.
          ]
          .iter()
          .sum()
      );

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_equal(
          decode_column::<String>(&mut encoded_data_cursor),
          [
              rle::Element {
                  element: "foo".to_string(),
                  run_length: 1,
              },
              rle::Element {
                  element: "foo".to_string(),
                  run_length: 1,
              },
              rle::Element {
                  element: "foo".to_string(),
                  run_length: 1,
              },
              rle::Element {
                  element: "bar".to_string(),
                  run_length: 1,
              },
              rle::Element {
                  element: "baz".to_string(),
                  run_length: 1,
              },
              rle::Element {
                  element: "foo".to_string(),
                  run_length: 1,
              },
          ],
      );
  }
#+end_src

#+begin_src rust :tangle src/test_lib.rs
  #[test]
  fn test_encode_decode_string_with_rle() {
      let data = ["foo", "foo", "foo", "bar", "baz", "foo"];
      let encoded_data = encode_column(data.into_iter(), true);
      assert_eq!(
          encoded_data.len(),
          [
              9, // magic_bytes
              1, // u8 header:data_type
              1, // u8 header:use_rle
              1, // varint header:element_count
              1, // varint header:data_size
              4, // data:element_1:rle_element string "foo" of encoding size 4.
              1, // data:element_1:rle_run_length varint of size 1.
              4, // data:element_2:rle_element string "bar" of encoding size 4.
              1, // data:element_2:rle_run_length varint of size 1.
              4, // data:element_3:rle_element string "baz" of encoding size 4.
              1, // data:element_3:rle_run_length varint of size 1.
              4, // data:element_3:rle_element string "foo" of encoding size 4.
              1, // data:element_3:rle_run_length varint of size 1.
          ]
          .iter()
          .sum()
      );

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_equal(
          decode_column::<String>(&mut encoded_data_cursor),
          [
              rle::Element {
                  element: "foo".to_string(),
                  run_length: 3,
              },
              rle::Element {
                  element: "bar".to_string(),
                  run_length: 1,
              },
              rle::Element {
                  element: "baz".to_string(),
                  run_length: 1,
              },
              rle::Element {
                  element: "foo".to_string(),
                  run_length: 1,
              },
          ],
      );
  }
#+end_src

* Format Specification
:PROPERTIES:
:CUSTOM_ID: FormatSpecification-zfj696o03tj0
:END:

** Format Overview
:PROPERTIES:
:CUSTOM_ID: FormatSpecificationFormatOverview-j3k696o03tj0
:END:

#+begin_src dot :file format-overview.png :exports results :cache yes
  digraph FormatOverview {
      node[shape=record];
      rankdir=LR;
      overview[label="<magicbytes> Magic Bytes|<header>Header|<data>Data..."];
      overview:magicbytes -> magicbytes;
      overview:header -> header;
      overview:data -> data;

      magicbytes[label="wmedrano0"];
      header[label="u8:data_type | u8:use_rle | varint:element_count | varint:data_size"];
      data[label="bincoded:element_1 | bincoded:element_2 | ... | bincoded:element_n"];
  }
#+end_src

#+RESULTS:
[[file:format-overview.png]]

#+begin_src rust :tangle src/lib.rs
  fn encode_column_impl<T>(
      data: impl ExactSizeIterator + Iterator<Item = T>,
      use_rle: bool,
  ) -> Vec<u8>
  where
      T: 'static + bincode::Encode + Eq,
  {
      let elements = data.len();
      let encoded_data = if use_rle {
          encode_data_rle_impl(data.into_iter())
      } else {
          encode_data_base_impl(data.into_iter())
      };
      let header = Header {
          data_type: DataType::from_type::<T>().unwrap(),
          use_rle,
          elements,
          data_size: encoded_data.len(),
      };
      encode_header_and_data(MAGIC_BYTES, header, encoded_data)
  }
#+end_src

#+begin_src rust :tangle src/lib.rs :exports none
  const BINCODE_DATA_CONFIG: bincode::config::Configuration = bincode::config::standard();

  fn encode_header_and_data(
      magic_bytes: &'static [u8],
      header: Header,
      encoded_data: Vec<u8>,
  ) -> Vec<u8> {
      assert_eq!(header.data_size, encoded_data.len());
      Vec::from_iter(
          magic_bytes
              .iter()
              .copied()
              .chain(header.encode())
              .chain(encoded_data.iter().copied()),
      )
  }

  fn decode_column_impl<T: 'static + bincode::Decode>(
      r: &'_ mut impl std::io::Read,
  ) -> impl '_ + Iterator<Item = rle::Element<T>> {
      let mut magic_string = [0u8; MAGIC_BYTES_LEN];
      r.read_exact(&mut magic_string).unwrap();
      assert_eq!(
          &magic_string, MAGIC_BYTES,
          "Expected magic string {:?}.",
          MAGIC_BYTES
      );
      let header = Header::decode(r);
      assert!(
          header.data_type.is_supported::<T>(),
          "Format of expected type {:?} does not support {:?}.",
          header.data_type,
          std::any::type_name::<T>(),
      );
      if header.use_rle {
          let rle_elements /*: impl Iterator<Item=Element<T>>*/ = decode_rle_data(header.elements, r);
          Either::Left(rle_elements)
      } else {
          let elements: DataDecoder<T, _> = DataDecoder::new(header.elements, r);
          let rle_elements = elements.map(|element| rle::Element {
              element,
              run_length: 1,
          });
          Either::Right(rle_elements)
      }
  }
#+end_src

** Magic Bytes
:PROPERTIES:
:CUSTOM_ID: FormatSpecificationMagicBytes-iyl7tna13tj0
:END:

The magic bytes are 9 bytes long with the contents being "wmedrano0".

#+begin_src rust :tangle src/lib.rs
  const MAGIC_BYTES: &[u8; MAGIC_BYTES_LEN] = b"wmedrano0";
  const MAGIC_BYTES_LEN: usize = 9;
#+end_src

** Header
:PROPERTIES:
:CUSTOM_ID: FormatSpecificationHeader-3tk696o03tj0
:END:

The header contains a Bincode encoded struct:

#+begin_src rust :exports none :tangle src/lib.rs
  impl Header {
      const CONFIGURATION: bincode::config::Configuration = bincode::config::standard();
  }

  impl DataType {
      const ALL_DATA_TYPE: [DataType; 2] = [DataType::Integer, DataType::String];

      fn from_type<T: 'static>() -> Option<DataType> {
          DataType::ALL_DATA_TYPE
              .into_iter()
              .find(|dt| dt.is_supported::<T>())
      }

      fn is_supported<T: 'static>(&self) -> bool {
          let type_id = TypeId::of::<T>();
          match self {
              DataType::Integer => [
                  TypeId::of::<i8>(),
                  TypeId::of::<u8>(),
                  TypeId::of::<i16>(),
                  TypeId::of::<u16>(),
                  TypeId::of::<i32>(),
                  TypeId::of::<u32>(),
                  TypeId::of::<i64>(),
                  TypeId::of::<u64>(),
              ]
              .contains(&type_id),
              DataType::String => {
                  [TypeId::of::<String>(), TypeId::of::<&'static str>()].contains(&type_id)
              }
          }
      }
  }

  impl Header {
      fn encode(&self) -> Vec<u8> {
          bincode::encode_to_vec(self, Self::CONFIGURATION).unwrap()
      }

      fn decode(r: &mut impl std::io::Read) -> Header {
          bincode::decode_from_std_read(r, Self::CONFIGURATION).unwrap()
      }
  }
#+end_src

#+begin_src rust :tangle src/lib.rs
  #[derive(Encode, Decode, PartialEq, Eq, Copy, Clone, Debug)]
  pub struct Header {
      pub data_type: DataType,
      pub use_rle: bool,
      pub elements: usize,
      pub data_size: usize,
  }

  #[derive(Encode, Decode, PartialEq, Eq, Copy, Clone, Debug)]
  pub enum DataType {
      Integer = 0,
      String = 1,
  }
#+end_src

* Data Encoding
:PROPERTIES:
:CUSTOM_ID: DataEncoding-sgl696o03tj0
:END:

** Basic Encoding
:PROPERTIES:
:CUSTOM_ID: DataEncodingBasicEncoding-e4m696o03tj0
:END:

The data consists of a sequence of encoded data. Encoding happens using the Rust
[[https:github.com/bincode-org/bincode][Bincode]] package to encode/decode each data element.

#+begin_src rust :tangle src/lib.rs
  fn encode_data_base_impl<T: 'static + bincode::Encode>(data: impl Iterator<Item = T>) -> Vec<u8> {
      let mut encoded = Vec::new();
      for element in data {
          bincode::encode_into_std_write(element, &mut encoded, BINCODE_DATA_CONFIG).unwrap();
      }
      encoded
  }
#+end_src

#+begin_src rust :tangle src/test_bincode.rs :exports none
  fn encoded_size<T: bincode::Encode>(element: T) -> usize {
      bincode::encode_to_vec(element, bincode::config::standard())
          .unwrap()
          .len()
  }
#+end_src

#+begin_src rust :tangle src/test_bincode.rs
  #[test]
  fn test_encoding_size() {
      // Small numbers are encoded efficiently.
      assert_eq!(encoded_size(1u8), 1);
      assert_eq!(encoded_size(-1i8), 1);
      assert_eq!(encoded_size(1u64), 1);
      assert_eq!(encoded_size(-1i64), 1);

      // Larger numbers use more bytes with varint encoding. This does not apply
      // to u8 and i8 which do not use varint.
      assert_eq!(encoded_size(255u16), 3);
      assert_eq!(encoded_size(255u8), 1);
      assert_eq!(encoded_size(127i8), 1);
      assert_eq!(encoded_size(-128i8), 1);

      // Derived types (like Structs and Tuples) take up as much space as their subcomponents.
      assert_eq!(encoded_size(1u64), 1);
      assert_eq!(encoded_size(25564), 3);
      assert_eq!(encoded_size((1u64, 255u64)), 4);
      assert_eq!(
          encoded_size(rle::Element {
              element: 1u64,
              run_length: 255
          }),
          4
      );

      // Strings take up string_length + 1.
      assert_eq!(encoded_size("string"), 7);
      assert_eq!(encoded_size(String::from("string")), 7);
      assert_eq!(encoded_size((1u8, String::from("string"))), 8);

      // Fixed sized slices take up space for each of its encoded
      // elements. Variable size slices (or slice references) and vectors take
      // up an additional varint integer of overhead for encoding the length.
      assert_eq!(encoded_size::<&[u8; 3]>(&[1u8, 2, 3]), 3);
      assert_eq!(encoded_size::<[u8; 3]>([1u8, 2, 3]), 3);
      assert_eq!(encoded_size::<&[u8]>(&[1u8, 2, 3]), 4);
      assert_eq!(encoded_size(vec![1u8, 2, 3]), 4);
  }
#+end_src

#+name: run-length-encoding
** Run Length Encoding
:PROPERTIES:
:CUSTOM_ID: DataEncodingRunLengthEncoding-0vm696o03tj0
:END:

Run length encoding [[[https://en.wikipedia.org/wiki/Run-length_encoding#:~:text=Run%2Dlength%20encoding%20(RLE),than%20as%20the%20original%20run.][Wikipedia]]] is a compression technique for repeated values.

TODO: Add visualization.

#+begin_src rust :tangle src/rle.rs
  #[derive(Encode, Decode, Copy, Clone, PartialEq, Debug)]
  pub struct Element<T> {
      // The underlying element.
      pub element: T,
      // Run length is stored as a u64. We could try using a smaller datatype,
      // but Bincode uses "variable length encoding" for integers which is
      // efficient for smaller sizes.
      pub run_length: u64,
  }
#+end_src

To encode an iterator of type ~T~ with RLE, it is first converted into an
iterator of type ~rle::Element<T>~. It is then used to encode the run length
encoded vector into bytes.

#+begin_src rust :tangle src/lib.rs
  fn encode_data_rle_impl<T: 'static + bincode::Encode + Eq>(
      data: impl Iterator<Item = T>,
  ) -> Vec<u8> {
      let rle_data /*: impl Iterator<Item=rle::Element<T>>*/ = rle::encode_iter(data);
      encode_data_base_impl(rle_data)
  }
#+end_src

#+begin_src rust :tangle src/lib.rs :exports none
  fn decode_rle_data<T: 'static + bincode::Decode>(
      elements: usize,
      r: &'_ mut impl Read,
  ) -> impl '_ + Iterator<Item = rle::Element<T>> {
      let mut elements = elements;
      std::iter::from_fn(move || {
          if elements == 0 {
              return None;
          }
          let rle_element: rle::Element<T> =
              bincode::decode_from_std_read(r, BINCODE_DATA_CONFIG).unwrap();
          assert!(
              rle_element.run_length as usize <= elements,
              "{} <= {}",
              elements,
              rle_element.run_length
          );
          elements -= rle_element.run_length as usize;
          Some(rle_element)
      })
  }

  struct DataDecoder<T, R> {
      reader: R,
      element_count: usize,
      element_type: PhantomData<T>,
  }

  impl<T, R> DataDecoder<T, R> {
      pub fn new(element_count: usize, reader: R) -> DataDecoder<T, R> {
          DataDecoder {
              reader,
              element_count,
              element_type: PhantomData,
          }
      }
  }

  impl<T, R> Iterator for DataDecoder<T, R>
  where
      T: bincode::Decode,
      R: Read,
  {
      type Item = T;

      fn next(&mut self) -> Option<T> {
          if self.element_count == 0 {
              return None;
          }
          self.element_count -= 1;
          let element: T =
              bincode::decode_from_std_read(&mut self.reader, BINCODE_DATA_CONFIG).unwrap();
          Some(element)
      }
  }
#+end_src

#+begin_src rust :tangle src/rle.rs
  pub fn encode_iter<I>(iter: I) -> impl Iterator<Item = Element<I::Item>>
  where
      I: Iterator,
      I::Item: PartialEq,
  {
      iter.peekable().batching(|iter| {
          let element = match iter.next() {
              Some(e) => e,
              None => return None,
          };
          let mut run_length = 1;
          while iter.next_if_eq(&element).is_some() {
              run_length += 1;
          }
          Some(Element {
              element,
              run_length,
          })
      })
  }
#+end_src

*** Tests
:PROPERTIES:
:CUSTOM_ID: DataEncodingRunLengthEncodingTests-xhn696o03tj0
:END:

#+begin_src rust :tangle src/test_rle.rs
  #[test]
  fn test_encode_data_without_elements_produces_no_elements() {
      let data: Vec<String> = vec![];
      assert_equal(encode_iter(data.into_iter()), []);
  }

  #[test]
  fn test_encode_data_combines_repeated_elements() {
      let data = [
          "repeated-3",
          "repeated-3",
          "repeated-3",
          "no-repeat",
          "repeated-2",
          "repeated-2",
          "repeated-3",
          "repeated-3",
          "repeated-3",
      ];
      assert_equal(
          encode_iter(data.into_iter()),
          [
              Element {
                  run_length: 3,
                  element: "repeated-3",
              },
              Element {
                  run_length: 1,
                  element: "no-repeat",
              },
              Element {
                  run_length: 2,
                  element: "repeated-2",
              },
              Element {
                  run_length: 3,
                  element: "repeated-3",
              },
          ],
      );
  }
#+end_src

* Source Code
:PROPERTIES:
:CUSTOM_ID: SourceCode-45o696o03tj0
:END:

The source code is stored at
[[https://github.com/wmedrano/wills-columnar-format]]. The main source file is
=wills-columnar-format.org= which is used to generate the Rust source files like
=src/lib.rs=.
