#+title: Will's Columnar Format
#+author: Will Medrano
#+email: will.s.medrano@gmail.com
#+date: 2023-04-18

* Introduction

[[https://wmedrano.dev/living-programs/wills-columnar-format][Will's columnar format]] is a columnar format made by will.s.medrano@gmail.com. It
is primarily implemented for educational purposes. If you are interested in
using a well supported columnar format, consider using [[https://parquet.apache.org/][Apache Parquet]].

** Conventions

The following conventions are used:
- All structs are encoded using [[https://github.com/bincode-org/bincode][Bincode]]. Bincode is a binary
  encoding/decoding scheme implemented in Rust.
- Source code snippets are presented for relatively high level constructs. Lower
  level details may be omitted from presentation.

* API

** V0 Features

V0 is roughly implemented but still requires graceful error handling, and
bench-marking.

Supports:
- Only a single column per encode/decode.
- ~i64~ and ~String~ types.
- Run length encoding.

** Tentative V1 Features

- Dictionary encoding for better string compression.
- Compression (like zstd or snappy) for data.
- Multiple columns.
- Push down filtering.
- Split column data into blocks. Required to implement effective push down filtering.


** Encoding

~encode_column~ encodes a ~Vec<T>~ into Will's Columnar Format. If ~use_rle~ is
true, then run length encoding will be used.

TODO: ~use_rle~ should have more granular values like =NEVER=, =ALWAYS=, and
=AUTO=.

#+BEGIN_SRC rust :tangle src/lib.rs :comments link
  pub fn encode_column<T>(data: Vec<T>, use_rle: bool) -> Vec<u8>
  where
      T: 'static + bincode::Encode + Eq {
      encode_column_impl(data, use_rle)
  }
#+END_SRC

** Decoding

~decode_column~ decodes data from a byte stream into a ~Vec<T>~.

TODO: Decoding should return an iterator of ~RleElement<T>~ to support efficient
reads of run-length-encoded data.

#+BEGIN_SRC rust :tangle src/lib.rs :comments link
  pub fn decode_column<T>(r: &mut impl std::io::Read) -> Vec<T>
  where
      T: 'static + Clone + bincode::Decode {
      decode_column_impl(r)
  }
#+END_SRC

** Tests

#+BEGIN_SRC rust :tangle src/lib.rs :comments link :exports none
  #[cfg(test)]
  mod test_lib;
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments link :exports none
  use super::*;
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments link
  #[test]
  fn test_header_contains_magic_bytes() {
      let data: Vec<i64> = vec![1, 2, 3, 4];
      let encoded_data = encode_column(data.clone(), false);
      assert_eq!(&encoded_data[0..MAGIC_BYTES_LEN], b"wmedrano0");
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments link
  #[test]
  fn test_encode_decode_i64() {
      let data: Vec<i64> = vec![-1, 10, 10, 10, 11, 12, 12, 10];
      let encoded_data = encode_column(data.clone(), false);
      assert_eq!(encoded_data.len(), 22);

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_eq!(
          decode_column::<i64>(&mut encoded_data_cursor),
          vec![-1, 10, 10, 10, 11, 12, 12, 10]);
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments link
  #[test]
  fn test_encode_decode_string() {
      let data: Vec<String> = Vec::from_iter([
          "foo",
          "foo",
          "foo",
          "bar",
          "baz",
          "foo",
      ].into_iter().map(String::from));
      let encoded_data = encode_column(data.clone(), false);
      assert_eq!(encoded_data.len(), 38);

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_eq!(
          decode_column::<String>(&mut encoded_data_cursor),
          vec!["foo", "foo", "foo", "bar", "baz", "foo"]);
  }
#+END_SRC

#+BEGIN_SRC rust :tangle src/test_lib.rs :comments link
  #[test]
  fn test_encode_decode_string_with_rle() {
      let data: Vec<String> = Vec::from_iter([
          "foo",
          "foo",
          "foo",
          "bar",
          "baz",
          "foo",
      ].into_iter().map(String::from));
      let encoded_data = encode_column(data.clone(), true);
      assert_eq!(encoded_data.len(), 34);

      let mut encoded_data_cursor = std::io::Cursor::new(encoded_data);
      assert_eq!(
          decode_column::<String>(&mut encoded_data_cursor),
          vec!["foo", "foo", "foo", "bar", "baz", "foo"]);
  }
#+END_SRC

* Format Specification

- =magic-bytes= - The magic bytes are "wmedrano0".
- =header= - The header contains metadata about the column.
- =data= - The encoded column data.

#+BEGIN_SRC rust :tangle src/lib.rs :comments link :exports none
  const MAGIC_BYTES_LEN: usize = 9;
  const MAGIC_BYTES: &[u8; MAGIC_BYTES_LEN] = b"wmedrano0";
  const BINCODE_DATA_CONFIG: bincode::config::Configuration = bincode::config::standard();

  fn encode_column_impl<T: 'static + bincode::Encode + Eq>(data: Vec<T>, use_rle: bool) -> Vec<u8> {
      let elements = data.len();
      let encoded_data = if use_rle {
          let rle_data = rle_encode_data(data.into_iter());
          bincode::encode_to_vec(rle_data, BINCODE_DATA_CONFIG).unwrap()
      } else {
          bincode::encode_to_vec(data, BINCODE_DATA_CONFIG).unwrap()
      };
      let header = Header{
          data_type: DataType::from_type::<T>().unwrap(),
          is_rle: use_rle,
          elements,
          data_size: encoded_data.len(),
      };
      Vec::from_iter(
          MAGIC_BYTES.iter().copied()
              .chain(header.encode())
              .chain(encoded_data.iter().copied()),
      )
  }

  fn decode_column_impl<T: 'static + Clone + bincode::Decode>(r: &mut impl std::io::Read) -> Vec<T> {
      let mut magic_string = [0u8; MAGIC_BYTES_LEN];
      r.read_exact(&mut magic_string).unwrap();
      assert_eq!(
          &magic_string, MAGIC_BYTES,
          "Expected magic string {:?}.",
          MAGIC_BYTES
      );
      let header = Header::decode(r);
      assert!(
          header.data_type.is_supported::<T>(),
          "Format of expected type {:?} does not support {:?}.",
          header.data_type,
          std::any::type_name::<T>(),
      );
      if header.is_rle {
          let rle_elements: Vec<RleElement<T>> =
              bincode::decode_from_std_read(r, BINCODE_DATA_CONFIG).unwrap();
          vec_from_iter_with_hint(
              rle_decode_data(rle_elements.iter()).cloned(),
              header.elements,
          )
      } else {
          bincode::decode_from_std_read(r, BINCODE_DATA_CONFIG).unwrap()
      }
  }

  fn vec_from_iter_with_hint<T>(iter: impl Iterator<Item = T>, len_hint: usize) -> Vec<T> {
      let mut ret = Vec::with_capacity(len_hint);
      ret.extend(iter);
      ret
  }
#+END_SRC

** Header

The header contains an encoded struct:

#+BEGIN_SRC rust :exports none :tangle src/lib.rs :comments link
  use bincode::{Decode, Encode};
  use std::any::TypeId;

  impl Header {
      const CONFIGURATION: bincode::config::Configuration = bincode::config::standard();
  }

  impl DataType {
      const ALL_DATA_TYPE: [DataType; 2] = [
          DataType::I64,
          DataType::String,
      ];
      fn from_type<T: 'static>() -> Option<DataType> {
          DataType::ALL_DATA_TYPE.into_iter().find(|dt| dt.is_supported::<T>())
      }

      fn supported_type_id(&self) -> TypeId {
          match self {
             DataType::I64 => TypeId::of::<i64>(),
             DataType::String => TypeId::of::<String>(),
          }
      }

      fn is_supported<T: 'static>(&self) -> bool {
          TypeId::of::<T>() == self.supported_type_id()
      }
  }

  impl Header {
      fn encode(&self) -> Vec<u8> {
          bincode::encode_to_vec(self, Self::CONFIGURATION).unwrap()
      }

      fn decode(r: &mut impl std::io::Read) -> Header {
          bincode::decode_from_std_read(r, Self::CONFIGURATION).unwrap()
      }
  }
#+END_SRC


#+BEGIN_SRC rust :tangle src/lib.rs :comments link
  #[derive(Encode, Decode, PartialEq, Eq, Copy, Clone, Debug)]
  pub struct Header {
      pub data_type: DataType,
      pub is_rle: bool,
      pub elements: usize,
      pub data_size: usize,
  }

  #[derive(Encode, Decode, PartialEq, Eq, Copy, Clone, Debug)]
  pub enum DataType {
      I64 = 0,
      String = 1,
  }
#+END_SRC

** Data

*** Basic Encoding

The data consists of a sequence of encoded data. Encoding happens using the
=bincode= package to encode/decode data of type ~&[T]~ and ~Vec<T>~.

*** RLE

[[https://en.wikipedia.org/wiki/Run-length_encoding#:~:text=Run%2Dlength%20encoding%20(RLE),than%20as%20the%20original%20run.][Run length encoding]] is a compression technique for repeated values.

For RLE, the data is encoded as a Struct with the run length and the
element. With Bincode, this is the equivalent of encoding a tuple of type
~(run_length, element)~.

#+BEGIN_SRC rust :tangle src/lib.rs :comments link
  #[derive(Encode, Decode, Copy, Clone, PartialEq, Debug)]
  pub struct RleElement<T> {
      pub run_length: u64,
      pub element: T,
  }

  fn rle_encode_data<T: Eq>(data: impl Iterator<Item = T>) -> Vec<RleElement<T>> {
      let mut data = data;
      let mut rle = match data.next() {
          Some(e) => RleElement{run_length: 1, element: e},
          None => return Vec::new(),
      };

      let mut ret = Vec::new();
      for element in data {
          if element != rle.element || rle.run_length == u64::MAX {
              ret.push(std::mem::replace(&mut rle, RleElement{run_length: 1, element}));
          } else {
              rle.run_length += 1;
          }
      }
      if rle.run_length > 0 {
          ret.push(rle);
      }
      ret
  }

  fn rle_decode_data<'a, T: 'static>(
      iter: impl 'a + Iterator<Item = &'a RleElement<T>>,
  ) -> impl Iterator<Item = &'a T> {
      iter.flat_map(move |rle| {
          let run_length = rle.run_length as usize;
          std::iter::repeat(&rle.element).take(run_length)
      })
  }
#+END_SRC

* Source Code

The source code is stored at
[[https://github.com/wmedrano/wills-columnar-format]]. The main source file is
=wills-columnar-format.org= which is used to generate the =src/lib.rs=.
